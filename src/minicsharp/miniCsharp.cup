
package minicsharp;
import java_cup.runtime.Symbol;





parser code {:
int errorCounter=0;
public void syntax_error(Symbol s){
        errorCounter++;

		report_error("Error de sintaxis recuperable No"+errorCounter+". Linea:"  + (s.right+1) +
		" Columna: " + (s.left+1) + ". Texto: \"" + s.value + "\"", null);
	}
public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception 
        {
         errorCounter++;

		report_error("Error de sintaxis no recuperable No"+errorCounter+". Linea:"  + (s.right+1) +
		" Columna: " + (s.left+1) + ". Texto: \"" + s.value + "\"", null);
        }




:}




/*TERMINAL*/
terminal IDENT,semicolon,INT,DOUBLE,BOOL,STRING,leftsquarebrace ,rightsquarebrace,leftparen,rightparen,VOID,comma,CLASS,leftbrace,rightbrace,extends_t,implements_t,interface_t,
IF,else_t,WHILE,FOR,RETURN,BREAK,Print,equal,THIS,New,NewArray,ReadInteger,Malloc,dot,getByte,SetByte,NULL,ReadLine,INTCONSTANT,DOUBLECONSTANT,BOOLEANCONSTANT,STRINGCONSTANT,comp,
arit,logic,minus,exclamation;


/*NON TERMINALS*/
non terminal PROG,DECL,DECLP,VARIABLEDECL,FUNCTIONDECL,CLASSDECL,INTERFACEDECL,VARIABLE,TYPE,FORMALS,STMTBLOCK,EXTENDSS,IMPLEMENT,FIELDP,FIELD,PROTOTYPEP,PROTOTYPE,VARIABLEDECLP,STMTP,STMT,
EXPRP,IFSTMT,WHILESTMT,FORSTMT,BREAKSTMT,RETURNSTMT,PRINTSTMT,EXPR,ELSESTMT,EXPRLIST,LVALUE,CONSTANT,CALL,ACTUALS,LIBCALL,IMPLEMENTP,LISTAVARIABLE;

/*PRECEDENCE*/
precedence left equal;
precedence left logic;
precedence nonassoc comp;
precedence left arit,minus;
precedence nonassoc exclamation;
precedence nonassoc leftsquarebrace,dot;
precedence nonassoc else_t;


/*START*/
start with PROG;


PROG::=DECL DECLP;
DECLP::= DECLP DECL|;    

DECL::=VARIABLEDECL|FUNCTIONDECL|CLASSDECL|INTERFACEDECL|error semicolon|error rightbrace;
VARIABLEDECL::=VARIABLE semicolon;
VARIABLE::=TYPE IDENT;
TYPE::=INT|DOUBLE|BOOL|STRING|IDENT|TYPE  leftsquarebrace rightsquarebrace ;
FUNCTIONDECL::=TYPE IDENT leftparen FORMALS rightparen STMTBLOCK|VOID IDENT leftparen FORMALS rightparen STMTBLOCK;
FORMALS::=VARIABLE LISTAVARIABLE|;
LISTAVARIABLE::=comma VARIABLE LISTAVARIABLE|;

CLASSDECL::=CLASS IDENT EXTENDSS IMPLEMENT leftbrace FIELDP rightbrace;
EXTENDSS::=extends_t IDENT| ;

IMPLEMENT::=implements_t IMPLEMENTP|;
IMPLEMENTP::= IDENT |IMPLEMENTP comma IDENT ;
FIELDP::= FIELDP FIELD|;
FIELD::=VARIABLEDECL|FUNCTIONDECL;



INTERFACEDECL::=interface_t IDENT leftbrace PROTOTYPEP rightbrace;
PROTOTYPEP::= PROTOTYPEP PROTOTYPE|;
PROTOTYPE::= TYPE IDENT leftparen FORMALS rightparen semicolon|VOID IDENT leftparen FORMALS rightparen semicolon;
STMTBLOCK::=leftbrace VARIABLEDECLP STMTP rightbrace;
VARIABLEDECLP::=   VARIABLEDECLP VARIABLEDECL| ;
STMTP::= STMTP STMT| ;

STMT::= EXPR semicolon
            |semicolon
            |IFSTMT
            |WHILESTMT
            |FORSTMT
            |BREAKSTMT
            |RETURNSTMT
            |PRINTSTMT
            |STMTBLOCK;





EXPRP::=  EXPR| ;
IFSTMT::= IF leftparen EXPR rightparen STMT ELSESTMT;
ELSESTMT::=else_t STMT|;
WHILESTMT::=WHILE leftparen EXPR rightparen STMT;
FORSTMT::=FOR leftparen EXPRP semicolon EXPR semicolon EXPRP rightparen STMT;
RETURNSTMT::=RETURN EXPRP semicolon;
BREAKSTMT::=BREAK semicolon;
PRINTSTMT ::= Print leftparen  EXPR EXPRLIST rightparen semicolon;
EXPRLIST::=comma EXPR EXPRLIST|;

EXPR::=   LVALUE equal EXPR
         |CONSTANT
         |LVALUE
         |THIS
         |CALL
         |leftparen EXPR rightparen
         |EXPR arit EXPR
         |EXPR minus EXPR
         |EXPR logic EXPR
         |EXPR comp  EXPR
         |minus EXPR
         |exclamation EXPR
         |New leftparen IDENT rightparen
         |NewArray leftparen EXPR comma TYPE rightparen
         |ReadInteger leftparen rightparen
         |ReadLine leftparen rightparen
         |Malloc leftparen EXPR rightparen;

LVALUE::=IDENT
         |EXPR dot IDENT
         |EXPR  leftsquarebrace EXPR rightsquarebrace;


CALL::=IDENT leftparen ACTUALS rightparen| EXPR dot IDENT leftparen ACTUALS rightparen|EXPR dot LIBCALL leftparen ACTUALS rightparen;
LIBCALL::=getByte leftparen EXPR rightparen|SetByte leftparen EXPR comma EXPR rightparen;
ACTUALS::= EXPR EXPRLIST|;
CONSTANT::=INTCONSTANT|DOUBLECONSTANT|BOOLEANCONSTANT|STRINGCONSTANT|NULL;


